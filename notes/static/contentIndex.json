{"ASD":{"title":"ASD","links":["Graph6.excalidraw","Graph62.excalidraw","Min-Heap","djikstragraph.excalidraw"],"tags":[],"content":"Graphs\nA graph is a athematical structure used to model pairwise relationships between objects. It consists of:\n\nVertices (Nodes): The objects or points in the graph.\nEdges: The connections between the vertices. These can be:\n\nDirected: Edges have a direction (e.g., A → B).\nUndirected: Edges have no direction (e.g., A ←&gt; B).\n\n\n\nGraphs are represented in two primary ways:\n\nAdjacency List: A list where each vertex points to a list of its adjacent vertices.\nAdjacency Matrix: A 2D matrix where the element at position [ i ][ j ] indicates the presence/weight of an edge from vertex i to vertex j.\n\nGraphs can also be:\n\nWeighted: Edges have weights (e.g., cost, distance).\nUnweighted: All edges are treated equally.\nCyclic: Contain cycles.\nAcyclic: Do not contain cycles.\nConnected: There is a path between every pair of vertices.\nDisconnected: At least one pair of vertices has no path connecting them.\n\nMinimum spanning trees\nGoals\n\nIt is a subgraph (includes all vertices but not all edges).\nThe goal is to find the lowest amount of edges with the lowest connection weight.\nThe result should be a tree (shouldn’t be cyclical)\n\nSpanning tree with unweighed edges\nTransclude of Graph6.excalidraw\n\\text{V - Graph Vertices, E - Graph Edges}\nV = \\{1, 2, 3, 4, 5, 6\\}\nE =\\{(1,2), (2,3), (3,4), (4,5), (5,6), (6,1)\\}\n\\text{V&#039; = MST Vertices, E&#039; = MST Edges}\nV&#039; = V\nE&#039; = \\{(1,2), (2,3), (3,4), (4,5), (5,6)\\}\n|E&#039;| = |V| - 1\nSame thing different way\nTransclude of Graph62.excalidraw\nPrims algorithm\nPrim’s algorithm is an algorithm for finding the minimum spanning trees of a graph. It is super simple.\nSteps\n\nChoose a vertice\nChoose a lowest cost edge connected to one of your already connected vertices.\nAdd the vertice that edge connects to to your list of connected vertices.\nSo in plain english just grow your tree from a single point always choosing the lowest cost edge and adding it to the tree.\n\nKruskals algorithm\nKruskals algo is an algo for finding the Minimum spanning trees of a graph. It is similiar to Prims algorithm.\nSteps.\n\nChoose a lowest cost edge.\nChoose another lowest cost edge, but only if adding it to your list of already selected edges doesn’t form a cycle (MST’s have to be trees and therefore not cyclical).\nkeep going until all edges are connected.\nThis way the time complexity will be: O(|V| \\times |E|)\nThis however can be improved when using Min Heap to store the edges, then it will take  O(n\\times \\log n)\n\nDjikstra’s algorithm\nFinds the shortest path from source node to every other node in the graph with non-negative weights (Use Bellman-Ford algorithm for negative edge weights).\nSteps:\n\nSet distance to source node to 0and all nodes not directly connected to source node to \\infty\nFind the node with the lowest distance (for first iteration, source node since all others are \\infty)\nFor each directly connected node to the selected one (not yet checked before), check if the distance to selected node + weight of connection to neighbouring node is smaller than the current distance to neighbouring node, if so, update it.\nRepeat until all nodes are processed.\n\nExample:\nTransclude of djikstragraph.excalidraw\ns → already selected\nstarting vortex → 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSelected vortex2345645045s10\\infty\\infty55045s10s10 + 15 = 25 &lt; \\infty\\infty2s25 + 20 = 45 &lt; 5045s10s25\\infty3s4545s10s25\\infty6s45s45s10s25s\\infty\nBellman-Ford algorithm\nDynamic programming Algorithm for finding shortes path from single source node to all other nodes in a Graph. Unlinke Djikstras algorithm it works with negative edge weights but does not work with negative weight cycles.\nIt works by checking all possible solutions therefore finding the best one. Repeatedly relaxes all edges n-1 times, where n = |V|.\nRelaxation is the same as in Djikstras algorithm:\nif (d[u] + c(u, v) &lt; d[v]:\n    d[v] = d[u] + c(u, v)\nSo if the distance to vortex u + weight of edge between u and v is less than the current distance to v then update it. With the exception that you can select any edge. Just make sure that at the end you checked all edges.\nSteps:\n\nSet the distance to each node to \\infty\nSelect an edge (that wasn’t selected before) and relax it.\nSelect another edge and relax again, continue for all edges.\nStart again from the start, relaxing all edges one by one.\nDo that n - 1 times where n = |V| or stop when no updates were made in an iteration.\n\nIt can take even O(n^3) with a complete Graph. (Connection between every node)\nIt will not work with graphs which have a negetive weight cycle. This means that there are some nodes that form a cycle and the sum of weights of edges between them is negative. In that case every iteration of bellman-ford will produce a new result.\nBut it can detect a negative weight cycle, by performing another iteration after already iterating n-1 times and checking if something changed. If that is the case then there is a negative weight cycle."},"Architecture":{"title":"Architecture","links":["x86","x64","Syscalls","Software-Interrupt"],"tags":[],"content":"RISC vs CISC:\n\nRISC stands for Reduced Instruction Set Computer example is RISC-V and ARM\nCISC stands for Complex Instruction Set Computer, intel x86, x64 and amd processors are all CISC.\n\nCISC has more instructions which are not necessary but are there to speed up some common operations. For example some Syscalls and Software Interrupts are converted to CPU operations."},"Array":{"title":"Array","links":[],"tags":[],"content":"// Implicit declaration\nlet arr = [1, 2, 3, 4];\n// explicit declaration\nlet arr: [i32, 4] = [1, 2, 3, 4];\n// autofill\nlet arr = [3, 4]; // three 4 times -&gt; [3, 3, 3, 3]"},"Asm":{"title":"Asm","links":[],"tags":[],"content":"x86re\nsyntax\nregular syntax is:\nINSTRUCTION DESTINATION, SOURCE\nif you see dest and source swapped you might be looking at AT&amp;T syntax which is:\nINSTRUCTION SOURCE, DESTINATION\nInstructions\nmov (register), (value)    ; set register to value\nadd (register), (value or register)   ; the result is stored in the register\njmp (address e.g. 0x10)    ; jump to an instruction at address, ip = 0x10\nint 0x2    ; check the IVT/IDT and do the [[software_interrupt]] found at 0x2\ncmp eax, ebx ; compare 2 registers if they are equal the &quot;zero flag (zf)&quot; will be set to 1 and 0 if they are not\njz 0x53298  ; jump to the selected addres if the &quot;zero flag (zf)&quot; is 0. jzn works the other way, jump if not zero\niret    ; return the IP to the place it was before the interrupt\nRegisters\nData Registers\n\nEAX: Accumulator, often for math and return values .\nEBX: Base, often holds function params and indexed addresses .\nECX: Count, for loop counts (prograrrmers: this is “i”) and function params .\nEDX: Data, general use and function params . Internally labeled boxes are subregisters which can be used.\n\nIndex Registers\n\nESI: Source Index, often stores constants or used as a pointer.\nEDI: Destination Index, often a destination for data or used as a pointer. Pointers Points to a memory location, generally expressed in hex. Example: Ox40154b.\nESP: Stack pointer, stores a pointer to top of stack.\nEBP: Base pointer, stores a pointer to base of current stack frame.\n\nFlags\nCertain instructions change flags, which are represented as simple 1 or 0 on a flag register. For example, if we perform an “add” between two numbers, we may have a few outcomes that we need to be aware of. Let’s say we compare two values to see if they are equal with CMP EDX, EAX. The “zero flag” will either be set to 1 if they are equal, or 0 if they are not. An instruction like JZ Ox40154b that jumps to memory location Ox40154b if the comparison equaled to zero would check this flag. Think of these as boolean variables.\n\nZF, “zero flag,” set if result is 0.\nSF, “sign flag,” set if a result is negative.\nOF, “overflow flag,” set if a result was larger than a register can hold. Let us say AL and DL are set to OxFF. ADD AL, DL would return a 9 bit character and therefore overflow the 8 bit register.\n\nCall stack\nlast in first out so push the arguments in reverse order then call the function and store the result in register\n\nStack frames have 4 different parts:\n\nParameters\nreturn addres (wherever the funciton what called from)\nEBP (Base pointer)\nLocal variables\n\n\nEBP points to the base of the stack frame\nESP points to the top of the stack (increases when values are popped of the stack and decreases when values are added to the stack)\n\nSimple Overview:\n\nWhen a function is called, the current EBP is pushed onto the stack.\nEBP is then assigned the value of ESP; EBP is now the base pointer to access vars and params.\nAs function runs, ESP will change as needed, EBP remains static.\nAs function terminates, ESP is set to EBP. Stack pointer is now set to top of stack to equal the base pointer. This frees memory allocated on the stack for local vars.\nEBP is now popped from the stack (remember, first in last out,) and EBP can be used again as base pointer.\nIn simpler terms, stack frames contain the EBP value of the functions caller (step 1.) Now we can use EBP register as this function’ s base pointer.\n\nWriting code\nSections\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSection NameDescriptionInfoNotes.textContains the code of the programExecutable by the CPURead-only to prevent modification.dataHouses the static data of the program that will be modified by during executionUsually stores globals and initialized dataMost likely will be read-write.bssStores uninitialized dataVariables sizes in the section are known but values are 0 at runtimeSaves memory because you don’t need to initialize variables.rdataStores read-only dataData is not modified during executionPrimary purpose is to hold constant data\nHello world\n \n; declare the entrypoint of the program itself\nglobal _start\n;\n; the keyword global makes the label (in this case _start) accessible from outside the current program.\n; This keyword tells the linker where the program starts\n;\n \n; initialized data section (readable and writeable data)\nsection .data\n    ; align the data in a 2-byte boundary - allows better memory access \n\talign 2\n\t\n\t; define a string followed by a newline character\n\thello: db &#039;Hello world!&#039;, 0xa\n\t\n\t; calculate the length of the string by subtracing from the current address\n\thelloLen: equ $-hello \n;\n; this section stores the data that will be used through the program. The align mnemonic ensures that the \n; string &#039;Hello, World!&#039; is aligned on a 2-byte boundary for easier memory access. It also houses the length\n; of the string.\n;\n \n; store uninitialized data\nsection .bss \n; \n; since there is no data that &quot;may&quot; be used, this section is empty\n; \n \n; store the actual code of the program\nsection .text\n\t\n\t; define the entrypoint where the program starts execution\n\t_start:\n\t  \n\t  ; syscall for sys_write\n  \t  mov eax, 0x4 \n  \t  \n  \t  ; file descriptor for stdout\n\t  mov ebx, 0x1  \n\t  \n\t  ; address of the initialized string\n\t  mov ecx, hello  \n\t  \n\t  ; length of the intialized string\n\t  mov edx, helloLen\n\t  \n\t  ; interrupt to make linux syscall  \n\t  int 0x80  \n\t  \n\t  ; syscall for sys_exit\n\t  mov eax, 0x1  \n\t  \n\t  ; exit status 0\n\t  xor ebx, ebx\n\t  \n\t  ; interrupt to make syscall  \n\t  int 0x80\n\t  ;\n\t  ; this intruction is used to trigger and interrupt and allows you to invoke a system call from \n\t  ; user space to kernel space. Basically we are requesting the OS for services.\n\t  ; This stops the processing and switches into kernel mode (ring0).\n\t  ;\n;\n; this section contains the actual program code. It starts with the _start label as the entrypoint\n; and makes multiple sys_calls. It then exits the program with an interrupt.\n;\n \n1. hello:\nThis defines a label named hello. In assembly, labels are used to mark memory locations. The label hello refers to the address where the string &#039;Hello world!&#039; is stored.\n2. db\n\ndb stands for “Define Byte.”\nIt is used to define a series of bytes that will be stored in memory.\nIn this case, the bytes represent the ASCII values of the characters in the string &#039;Hello world!&#039;, followed by 0xa (which is a newline character in hexadecimal).\n\n3. 0xa\n\nThis is a hexadecimal representation of the number 10 (decimal), which corresponds to the ASCII newline character (&#039;\\n&#039;).\nIn this context, it is used to signify the end of the string with a newline.\n\n4. equ\n\nequ stands for “equate.”\nIt is a directive used to assign a value to a label or symbol at assembly time.\nUnlike variables, which store values in memory, symbols defined with equ are constant and evaluated by the assembler during compilation.\n\n5. $\n\n$ represents the current address or current location counter. It points to the memory address the assembler is currently processing.\nIn this case, $ is used to get the memory address right after the string &quot;Hello world!\\n&quot; has been defined.\n\n6. helloLen: equ $-hello\nThis line calculates the length of the string stored in the label hello:\n\n$ gives the memory address right after the string (the end of the string).\nhello is the address where the string starts.\nThe expression $ - hello calculates the number of bytes between the current address (after the string) and the starting address of the string.\n\nThis difference gives the length of the string, which is stored in helloLen. Since the string is 12 characters long (&quot;Hello world!&quot;) plus a newline character (0xA), the total length would be 13 bytes.\ncompiling and running\nnasm -f elf32 -o filename.o filename.asm\nld -m elf_i386 -o filename filename.o\n./filename\nfunctions\nmake a function anythwere in the file by adding a label: hello:  and some instructions under it. finish it with ret. ret is automatically pushed onto the stack, remember when popping of the stack with [bp + offset]\nsection .text\n \nwriteHello:\n\tmov eax, 0x4\n\tmov ebx, 0x1\n\tmov ecx, hello\n\tmov edx, helloLen\n\tint 0x80\n\tret\n \nwriteBye:\n\tmov eax, 0x4\n\tmov ebx, 0x1\n\tmov ecx, goodbye\n\tmov edx, byeLen\n\tint 0x80\n\tret\n \n_start:\n\tmov eax, 0x4\n\tmov ebx, 0x4\n\tcmp eax, ebx\n\tje equal\n\tjne notEqual\n \nequal:\n\tcall writeHello\n\tjmp endProgram\n \nnotEqual:\n\tcall writeBye\n \nendProgram:\n\t; return 0\n\tmov eax, 0x1\n\txor ebx, ebx\n\tint 0x80"},"Asymptotic-notation":{"title":"Asymptotic notation","links":["O-notation","Omega-notation","Theta-notation","Algorithm-Analysis","Asymptotic-relations"],"tags":[],"content":"Asymptotic Notation is a way to describe how the performance of an algorithm changes as the input size grows. It helps us understand the efficiency of an algorithm without needing exact details. The three most common types are:\n\nO notation: Describes the worst-case scenario—how long an algorithm could take.\nΩ notation: Describes the best-case scenario—how quickly an algorithm could finish.\nΘ notation: Describes the average-case scenario—how long an algorithm usually takes.\n\n\nThese notations are key in analyzing algorithms to predict their scalability with larger inputs.\nYou can also express relation between functions using asymptotic notation.\nAsymptotic notatnion in relation to eachother"},"Asymptotic-relations":{"title":"Asymptotic relations","links":[],"tags":[],"content":""},"Athena":{"title":"Athena","links":["S3","Glue-Crawler"],"tags":[],"content":"Requires 2 S3 buckets, 1 with the data e.g. a csv file with customer info and another for output.\n\nTo start querying, create a table from S3 datasource or with AWS Glue Crawler, in Data format  section choose the file format of your data, the rest is how the data will be stored and most of the time doesn’t matter.\nNext choose the format of columns in Column details section. Remember to remove all quotes and misplaced commas since this will not fix it for you.\n"},"Aurora":{"title":"Aurora","links":["RDS"],"tags":[],"content":"subset of RDS, supports serverless version and optimized read-only and read+write instances."},"Autounnatend.xml":{"title":"Autounnatend.xml","links":[],"tags":[],"content":"ltsc-like\n\n\nInstall necessary tools:\nFirst, ensure you have the required tools installed. Open a terminal and run:\nsudo apt update\nsudo apt install genisoimage p7zip-full\n\n\n\nCreate a working directory:\nmkdir win11_iso_mod\ncd win11_iso_mod\n\n\n\nMount the ISO:\nsudo mkdir /mnt/win11iso\nsudo mount -o loop path/to/your/windows11.iso /mnt/win11iso\n\nReplace “path/to/your/windows11.iso” with the actual path to your ISO file.\n\n\nCopy ISO contents:\nmkdir iso_contents\ncp -r /mnt/win11iso/* iso_contents/\n\n\n\nUnmount the ISO:\nsudo umount /mnt/win11iso\n\n\n\nAdd your autounattend.xml:\ncp path/to/your/autounattend.xml iso_contents/\n\nReplace “path/to/your/autounattend.xml” with the actual path to your autounattend.xml file.\n\n\nRecreate the ISO:\ngenisoimage -udf -allow-limited-size -iso-level 3 -b boot/etfsboot.com -no-emul-boot -boot-load-size 8 -hide boot.catalog -eltorito-alt-boot -b efi/microsoft/boot/efisys.bin -no-emul-boot -o win11_modified.iso iso_contents/\n\nThis command creates a new ISO file named “win11_modified.iso” in your current directory.\n\n\nClean up:\nrm -rf iso_contents\n\n\n\nAfter these steps, you should have a new ISO file named “win11_modified.iso” that includes your autounattend.xml file.\nSome important notes:\n\nEnsure you have enough disk space to work with the ISO contents.\nThe exact parameters for the genisoimage command might need adjustment depending on the specific structure of your Windows 11 ISO.\n"},"Bash":{"title":"Bash","links":[],"tags":[],"content":"Unix shell programming language.\nThe | pipe operator is used for function composition.\n# redirect stderr to stdout, &gt;&amp; passes output to a file descriptor\n./program 2&gt;&amp;1 ( | grep test)\n \n# see redirected / piped stdout (duplicate output)\necho &quot;Hi&quot; | tee file1 (file2 ...)"},"Bellman-Ford-algorithm":{"title":"Bellman-Ford algorithm","links":["Dynamic-programming","Graphs-(DSA)","Djikstras-algorithm"],"tags":[],"content":"Dynamic programming Algorithm for finding shortes path from single source node to all other nodes in a Graph. Unlinke Djikstras algorithm it works with negative edge weights but does not work with negative weight cycles.\nIt works by checking all possible solutions therefore finding the best one. Repeatedly relaxes all edges n-1 times, where n = |V|.\nRelaxation is the same as in Djikstras algorithm:\nif (d[u] + c(u, v) &lt; d[v]:\n    d[v] = d[u] + c(u, v)\nSo if the distance to vortex u + weight of edge between u and v is less than the current distance to v then update it. With the exception that you can select any edge. Just make sure that at the end you checked all edges.\nSteps:\n\nSet the distance to each node to \\infty\nSelect an edge (that wasn’t selected before) and relax it.\nSelect another edge and relax again, continue for all edges.\nStart again from the start, relaxing all edges one by one.\nDo that n - 1 times where n = |V| or stop when no updates were made in an iteration.\n\nIt can take even O(n^3) with a complete Graph. (Connection between every node)\nIt will not work with graphs which have a negetive weight cycle. This means that there are some nodes that form a cycle and the sum of weights of edges between them is negative. In that case every iteration of bellman-ford will produce a new result.\nBut it can detect a negative weight cycle, by performing another iteration after already iterating n-1 times and checking if something changed. If that is the case then there is a negative weight cycle."},"Binary-Search-Trees":{"title":"Binary Search Trees","links":["Binary-Tree","Self-Balancing-BST"],"tags":[],"content":"BST are Binary Tree’s where left child of each node is smaller then the node and right child is bigger. That optimizes searching.\nThey are a broad category with many more specific implementations such as Self Balancing BST’s"},"Binary-Tree":{"title":"Binary Tree","links":["Data-Structures-and-Algorithms","Binary-Search-Trees"],"tags":[],"content":"Binary trees are data structures that are built on nodes and each node has at most 2 childen.\nMost common usage are Binary Search Trees"},"C":{"title":"C","links":["Gdb"],"tags":[],"content":"Known for being a successor of B.\nInput / Output\nfgets(buf, sizeof(buf),  [[Streams|stream]])\nreads at most sizeof(buf) - 1 bytes or until a newline, leaves room for null terminator\ntesting123(enter)\n-&gt; &quot;Testing123\\n\\0&quot;\n\nString formatting\nstrncpy(src, dest, maxline)\nCopies src to dest, at most maxline characters.\nsnprintf(result, maxline, &quot;format %s\\n&quot;, args)\nStreams\nfile descriptors to a stream of data\nPredefined:\n\nstdin\nstdout\nstderr\ncopies into result, at most maxline characters that result from the format\n\nDebugging\nUse Gdb"},"CPP":{"title":"CPP","links":["Lambda-Expressions","Types-(CPP)"],"tags":[],"content":"C++ is a subset of C with a growing number of modern features such as Lambda Expressions.\nTypes\n\nTypes (CPP)\n"},"Capture-The-Flag":{"title":"Capture The Flag","links":[],"tags":[],"content":"Hacking / Cybersecurity competition."},"Category-Theory":{"title":"Category Theory","links":["Haskell"],"tags":[],"content":"Abstract branch of mathematics especially useful in programming, popular functional programming languages like Haskell.\nWhat is a category?\nA bunch of objects and arrows (morphisms(functions)) that go between them, or more accurately it is the essence of composition. Arrows compose. If there exists and arrow from object A to object B and an arrow from object B to object C then there has to exist an arrow from object A to object C (their composition).\nArrows as functions.\nThe above example with objects A, B and C can be represented with arrows (morphisms) as functions the following way:\nf(A) = B \\ \\land \\ g(B) = C \\implies g(f(A)) = C\nor equally valid: g \\circ f. (notice the right to left order).\nIt can be read as “g after f”.\nProperties of composition.\n\nIt’s associative, if you have three morphisms that match end to end (like above f(A) = B \\ \\land \\ g(B) = C \\ \\land \\ h(C) = D then  you can compose them freely (maintaining order) (f \\circ g) \\circ h = f \\circ (g \\circ h) = f\\circ g \\circ h.\nFor every object A there is an arrow which is a unit of composition. This arrow loops from the object to itself. Being a unit of composition means that when composed with any arrow that either starts at A or ends at A respectively, it gives back the same arrow. The unit arrow for object A is called \\textbf{id}_{A} . In math notation if A goes to B then f \\circ \\textbf{id}_{A} = f and \\textbf{id}_{B} \\circ f= f. It is similar to how 0 is the additive identity and 1 is the multiplicative identity. It does not change anything about the morphism. e.g.\n\nid :: a -&gt; a\nid x = x"},"Classical-physics":{"title":"Classical physics","links":["Quantum-mechanics","Physics","System"],"tags":[],"content":"Classical physics refers to everything before the invention of Quantum mechanics. This is what most people think of when you mention Physics. Predicting what will happen in a System, shooting canonballs and blocks sliding on slopes included."},"Cloud":{"title":"Cloud","links":["Athena","S3","Glue-Crawler","RDS","Aurora","DynamoDB"],"tags":[],"content":"TODO:\n\nGo through uni lab’s again and note down what each service is good for, when to use them, when to avoid them and how to use them.\n\nAWS\n\nAthena: a service to quickly query data from S3 buckets with sql. Also integrates well with Glue Crawler for automatically creating columns.\nS3: Cloud object storage, fast and simple with options for long-term low-access rate storage with Glacier.\nRDS: Relational databases, both classic mysql / postgresql and newer serverless Aurora versions.\nDynamoDB\n"},"CompProg":{"title":"CompProg","links":["3.-Longest-Substring-Without-Repeating-Characters","4.-Longest-common-prefix","Contains-Duplicate"],"tags":[],"content":"Leetcode\n\n3. Longest Substring Without Repeating Characters\n4. Longest common prefix\n\nNeetcode\n\nContains Duplicate\n\nCodeForces"},"Competitions":{"title":"Competitions","links":["Hackathons","Capture-The-Flag","Comptitive-Programming","Cryptohack","CompProg","Code-Forces","pnwable.kr"],"tags":[],"content":"\nHackathons\nCapture The Flag\nComptitive Programming\nCryptohack\nCompProg\nCode Forces\npnwable.kr\n"},"Comptitive-Programming":{"title":"Comptitive Programming","links":["MITIT"],"tags":[],"content":"Leetcode style question tournament.\n\nMIT(IT^2)\n\n"},"Computational-Complexity-Theory":{"title":"Computational Complexity Theory","links":["Data-Structures-and-Algorithms"],"tags":[],"content":"In theoretical computer science and mathematics, computational complexity theory focuses on classifying computational problems according to their resource usage, and explores the relationships between these classifications. A computational problem is a task solved by a computer. A computation problem is solvable by mechanical application of mathematical steps, such as an algorithm."},"Conservation-law":{"title":"Conservation law","links":["State-of-a-system"],"tags":[],"content":"Whenever a system’s state-space, gets seperated into cycles we “remember” it and call it Q and give it a number. e.g.\nState-Space: \\{A, B, C, D\\}\nRules:\n\nWhenever we are at A next state we will go to A. (A -&gt; A)\nWhenever we are at B next state we will go to B. (B -&gt; B)\nWhenever we are at C next state we will go to D. (C -&gt; D)\nWhenever we are at D next state we will go to C. (D-&gt;C)\n\nThere are 3 cycles here so we can name them \\{-1, 0, 1\\}."},"Cryptohack":{"title":"Cryptohack","links":[],"tags":[],"content":"string to numbers(take the ordinal bytes of the message, convert them into hexadecimal, and concatenate)\nmessage: HELLO  \nascii bytes: [72, 69, 76, 76, 79]  \nhex bytes: [0x48, 0x45, 0x4c, 0x4c, 0x4f]  \nbase-16: 0x48454c4c4f  \nbase-10: 310400273487\n\npip install pycryptodome\nfrom Crypto.Util.number import *\nmsg = &#039;hello from the other side&#039;\nn = bytes_to_long(msg)\nmsg = long_to_bytes(n)\nXOR (We can XOR integers by first converting the integer from decimal to binary)\na = &#039;&#039;\nfor ch in &#039;label&#039;:\n...     a += chr(ord(ch) ^ 13)\n# or\n# pip install pwntools\nfrom pwn import xor\n \nciphertext = &quot;5d41402abc4b2a76b9719d911017c592&quot;\nkey = &quot;secret&quot;\n \nxored = xor(bytes.fromhex(ciphertext), key.encode())\n "},"Data-Structures-and-Algorithms":{"title":"Data Structures and Algorithms","links":["Asymptotic-notation","Algorithm-design-techniques","Divide-and-conquer","Dynamic-programming","Greedy-algorithms","Graph-algorithms","Minimum-spanning-trees","Shortest-paths","Maximum-flow","NP-completeness","Algorithm-analysis","Computer-science"],"tags":[],"content":"Data structures and algorithms are essential components in computer science, focusing on efficient problem-solving. Asymptotic notation, is used to analyze algorithm efficiency. Algorithm design techniques such as Divide and conquer, Dynamic programming, and Greedy algorithms provide strategies for tackling challenging problems. Graph algorithms, including those for Minimum spanning trees, Shortest paths, and Maximum flow, are vital for network-related issues. Understanding NP-completeness is key to grasping computational complexity. These concepts form the foundation of Algorithm analysis and advanced Computer science, enabling the development of efficient solutions to complex computational problems."},"Django":{"title":"Django","links":[],"tags":[],"content":"To create a project run django-admin startproject name\nmysite/\n    manage.py\n    mysite/\n        __init__.py\n        settings.py\n        urls.py\n        asgi.py\n        wsgi.py\n\nThese files are:\n\nThe outer mysite/ root directory is a container for your project. Its name doesn’t matter to Django; you can rename it to anything you like.\nmanage.py: A command-line utility that lets you interact with this Django project in various ways. You can read all the details about manage.py in django-admin and manage.py.\nThe inner mysite/ directory is the actual Python package for your project. Its name is the Python package name you’ll need to use to import anything inside it (e.g. mysite.urls).\nmysite/__init__.py: An empty file that tells Python that this directory should be considered a Python package. If you’re a Python beginner, read more about packages in the official Python docs.\nmysite/settings.py: Settings/configuration for this Django project. Django settings will tell you all about how settings work.\nmysite/urls.py: The URL declarations for this Django project; a “table of contents” of your Django-powered site. You can read more about URLs in URL dispatcher.\nmysite/asgi.py: An entry-point for ASGI-compatible web servers to serve your project. See How to deploy with ASGI for more details.\nmysite/wsgi.py: An entry-point for WSGI-compatible web servers to serve your project. See How to deploy with WSGI for more details.\n\napps\na project may have multiple apps and an app may be in multiple projects\npython manage.py startapp polls\nThat’ll create a directory polls, which is laid out like this:\npolls/\n    __init__.py\n    admin.py\n    apps.py\n    migrations/\n        __init__.py\n    models.py\n    tests.py\n    views.py\n\nThis directory structure will house the poll application."},"Djikstras-algorithm":{"title":"Djikstras algorithm","links":["Bellman-Ford-algorithm","djikstragraph.excalidraw"],"tags":[],"content":"Finds the shortest path from source node to every other node in the graph with non-negative weights (Use Bellman-Ford algorithm for negative edge weights).\nSteps:\n\nSet distance to source node to 0and all nodes not directly connected to source node to \\infty\nFind the node with the lowest distance (for first iteration, source node since all others are \\infty)\nFor each directly connected node to the selected one (not yet checked before), check if the distance to selected node + weight of connection to neighbouring node is smaller than the current distance to neighbouring node, if so, update it.\nRepeat until all nodes are processed.\n\nExample:\nTransclude of djikstragraph.excalidraw\ns → already selected\nstarting vortex → 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSelected vortex2345645045s10\\infty\\infty55045s10s10 + 15 = 25 &lt; \\infty\\infty2s25 + 20 = 45 &lt; 5045s10s25\\infty3s4545s10s25\\infty6s45s45s10s25s\\infty"},"Dynamical-law":{"title":"Dynamical law","links":["State-variables"],"tags":[],"content":"Dynamical law or a law of motion is a rule that tells us the next state given the current state.\ne.g. The next state could be the same as current state so with the example of  a coin on a table there are 2 possible histories\n\n\\{H, H, H, H, \\dots\\}\n\\{T, T, T, T, T, \\dots\\}\nOr it could be the oposite:\n\\{H, T, H, T, H, \\dots\\}\n\nIf the system is dynamical that means there is some variable that describes it. Such a variable is called \\sigma.\nA valid dynamical law also has to be reversible as well as deterministic, that means that we can know for sure the history of the state given the current state. There is no ambiguity, When described as objects with arrows there are no 2 arrows going to or from any object."},"Dynamical-system":{"title":"Dynamical system","links":["System","Dynamical-law","Conservation-law"],"tags":[],"content":"Dynamical system is a System which changes with time. It consists of more than a space of states but also a Dynamical law (law of motion).\nWhen a system has more than 1 cycle or can go into 2 seperate “branches” we make use of the Conservation law to describe it."},"DynamoDB":{"title":"DynamoDB","links":[],"tags":[],"content":"Non-relational DB (document database like mongodb). Just create table and add items."},"Endiannes":{"title":"Endiannes","links":["PE","ELF"],"tags":[],"content":"the number\n0x200 = 512\nbig endian - regular most significant bit on the left\n0x20 00\nlittle endian - reversed most significant bit on right\n0x00 02\nPE executables (windows .exe files) are always little endian however other formats such as ELF might not be"},"Error-Function":{"title":"Error Function","links":[],"tags":[],"content":"Function that returns the error value, calculating it based on the output given and the output wanted.\nPython example:\n    def get_error(self, model_prediction: NDArray[np.float64], ground_truth: NDArray[np.float64]) -&gt; float:\n \n        errors = []\n        for idx,_ in enumerate(model_prediction):\n            errors.append(np.square(model_prediction[idx] - ground_truth[idx]))\n        errors.sort()\n        return round(np.mean(errors), 5)\n        # model_prediction is an Nx1 NumPy array\n        # ground_truth"},"Executable-Formats":{"title":"Executable Formats","links":["ELF","Linux","PE","AIF","Endiannes"],"tags":[],"content":"ELF - Linux executable (Executable linkable format)\nPE - Windows exe (Portable executable)\nAIF - ARM exe (Arm image file)\nLSB - little endian\n??? - big endian\nstatically linked - libraries are outside of the executable"},"Fail2ban":{"title":"Fail2ban","links":[],"tags":[],"content":"bans an ip when it detects suspicious traffic such as too many requests.\nbasic setup:\n\nsudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local\nsudo nano /etc/fail2ban/jail.local\nconfigure as needed\nstart with systemctl start fail2ban and systemctl enable fail2ban\n\n"},"Gaussian-distribution":{"title":"Gaussian distribution","links":["Standard-deviation"],"tags":[],"content":"Gaussian (normal) distribution defines what normal means.\nIt is defined as y=\\frac{1}{\\sqrt{2\\pi\\sigma}}e^{\\frac{-(x-\\mu)^2}{2\\sigma^2}}Where:\nx - any value that can be measured\ny - relative frequency of x\n\\mu - center of the distribution\n\\sigma - Standard deviation\ne, \\pi - constants\n"},"Gaussian-processes":{"title":"Gaussian processes","links":["Linear-regression","classification","clustering","Multivariate-Gaussian-distribution"],"tags":[],"content":"article\nUsed to make predictions about data based on prior knowledge. e.g. look at many games of a basketball player to determine his skill\nCan be used to fit a function to data (Linear regression) but also do classification and clustering.\nGaussian processes are heavily based on Multivariate Gaussian distribution"},"Gdb":{"title":"Gdb","links":[],"tags":[],"content":"Gnu Debugger.\ncompiling C code with debug symbols\ngcc main.c -ggdb\n\nstarting gdb\ngdb exec main\n\nrunning program\nr (run)\n\nbreakpoints\nbreak foo\nbreak main.c:45\ninfo break      # list bp\ndel (number)    # remove bp \n\nlook at variables\ninfo locals (function_name)\nprint foo (sizeof(foo))\nexplore foo\n\ncheck what functions are available\ninfo functions\ndisassemble (func name or address)\n"},"Glue-Crawler":{"title":"Glue Crawler","links":["S3","RDS","DynamoDB"],"tags":[],"content":"Scans data sources (S3 buckets, RDS, DynamoDB, etc) to automatically discover the schema and metadata.\n\nChoose datasource and add classifiers\n"},"Gradient-descent":{"title":"Gradient descent","links":["Error-Function"],"tags":[],"content":"In ML gradient descent i used to approximate the minimum of the Error Function (or loss function) . By decrementing the X (guess) by the product of it’s derivative and \\alpha (learning rate usually 0.01 / 0.1).\n\nSo if your error function is x^2 then the derivative is x \\times 2 so every iteration you would do:\n\nstart with a guess: e.g. guess = 5\nguess -= derivative(guess) * learing_rate (or alpha)\n\nin Python for f_e(x) = x^2:\nclass Solution:\n    def get_minimizer(self, iterations: int, learning_rate: float, init: int) -&gt; float:\n \n        guess = init\n        for i in range(iterations):\n            guess -= (2 * guess) * learning_rate\n \n        return round(guess, 5)"},"Gradle-Build-file":{"title":"Gradle Build file","links":["Gradle","Gradle-Settings-file","(400)-Personal/Code/Java/Tools/Tools"],"tags":[],"content":"Gradle config file, one of main 2 along with settings.gradle.\nbuild.gradle file for a Minecraft mod in detail:\nplugins {\n    id &#039;eclipse&#039;\n    id &#039;maven-publish&#039;\n    id &#039;net.minecraftforge.gradle&#039; version &#039;5.1.+&#039;\n}\nThis section defines the plugins used in the project:\n\neclipse: Generates Eclipse project files.\nmaven-publish: Allows publishing artifacts to Maven repositories.\nnet.minecraftforge.[[gradle]]: The Forge Gradle plugin, essential for Minecraft modding.\n\nversion = &#039;1.0&#039;\ngroup = &#039;com.yourname.modid&#039;\narchivesBaseName = &#039;modid&#039;\nThese lines set basic project information:\n\nversion: Your mod’s version.\ngroup: The package structure of your mod.\narchivesBaseName: The base name for the output JAR file.\n\njava.toolchain.languageVersion = JavaLanguageVersion.of(17)\nThis specifies that the project should use Java 17.\nminecraft {\n    mappings channel: &#039;official&#039;, version: &#039;1.18.2&#039;\n    runs {\n        client {\n            workingDirectory project.file(&#039;run&#039;)\n            property &#039;forge.logging.markers&#039;, &#039;REGISTRIES&#039;\n            property &#039;forge.logging.console.level&#039;, &#039;debug&#039;\n            mods {\n                modid {\n                    source sourceSets.main\n                }\n            }\n        }\n    }\n}\nThis minecraft block configures the Forge development environment:\n\nmappings: Specifies which mappings to use for deobfuscation.\nruns: Configures the Minecraft client run configuration.\nworkingDirectory: Sets the working directory for the Minecraft client.\nproperty: Sets various Forge properties.\nmods: Specifies which mod(s) to load when running the client.\n\ndependencies {\n    minecraft &#039;net.minecraftforge:forge:1.18.2-40.1.0&#039;\n}\nThis declares the Forge dependency, specifying the Minecraft and Forge versions.\njar {\n    manifest {\n        attributes([\n            &quot;Specification-Title&quot;: &quot;modid&quot;,\n            &quot;Specification-Vendor&quot;: &quot;yourname&quot;,\n            &quot;Specification-Version&quot;: &quot;1&quot;,\n            &quot;Implementation-Title&quot;: project.name,\n            &quot;Implementation-Version&quot;: &quot;${version}&quot;,\n            &quot;Implementation-Vendor&quot; :&quot;yourname&quot;,\n            &quot;Implementation-Timestamp&quot;: new Date().format(&quot;yyyy-MM-dd&#039;T&#039;HH:mm:ssZ&quot;)\n        ])\n    }\n}\nThis jar block configures the JAR file creation:\n\nIt sets various manifest attributes, which provide metadata about the mod.\nThe Implementation-Timestamp is dynamically set to the build time.\n\nAdditional notes:\n\nThe Forge Gradle plugin adds many implicit tasks and configurations not visible in this file.\nIt sets up the deobfuscation process, which is crucial for modding.\nIt configures the Java compilation process to work with Minecraft’s obfuscated code.\nIt sets up the necessary classpath for compiling against Forge and Minecraft.\n\nThis build.[[gradle]] file is relatively minimal. For more complex mods, you might see additional configurations like:\n\nCustom tasks for processing resources or generating code.\nAdditional run configurations (e.g., for a dedicated server).\nMore complex dependency management.\nIntegration with other Tools or services.\n"},"Gradle":{"title":"Gradle","links":["make","Gradle-Build-file"],"tags":[],"content":"Kind of like make but for java. Automates compiling, running, dependency management, testing and deploying\n\nIt uses build_scripts written in groovy or kotlin to define project structure and build process the main one is called Gradle Build file.\nAutomatically downloads and manages dependencies\nSplits the work into tasks\nSupports plugins, for minecraft there is a forge gradle plugin.\n"},"Graph-algorithms":{"title":"Graph algorithms","links":["Graphs-(DSA)","Minimum-spanning-trees"],"tags":[],"content":"Algorithms for traversing Graphs, making Minimum spanning trees among others."},"Graph6.excalidraw":{"title":"Graph6.excalidraw","links":[],"tags":["excalidraw"],"content":"⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠ You can decompress Drawing data with the command palette: ‘Decompress current Excalidraw file’. For more info check in plugin settings under ‘Saving’\nExcalidraw Data\nText Elements"},"Graph62.excalidraw":{"title":"Graph62.excalidraw","links":[],"tags":["excalidraw"],"content":"⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠ You can decompress Drawing data with the command palette: ‘Decompress current Excalidraw file’. For more info check in plugin settings under ‘Saving’\nExcalidraw Data\nText Elements"},"Graphs-(DSA)":{"title":"Graphs (DSA)","links":["Data-Structures-and-Algorithms","Prims-algorithm","Minimum-spanning-trees","Kruskals-algorithm","Djikstras-algorithm","Bellman-Ford-algorithm"],"tags":[],"content":"A graph is a mathematical structure used to model pairwise relationships between objects. It consists of:\n\nVertices (Nodes): The objects or points in the graph.\nEdges: The connections between the vertices. These can be:\n\nDirected: Edges have a direction (e.g., A → B).\nUndirected: Edges have no direction (e.g., A ↔ B).\n\n\n\nGraphs are represented in two primary ways:\n\nAdjacency List: A list where each vertex points to a list of its adjacent vertices.\nAdjacency Matrix: A 2D matrix where the element at position [ i ][ j ] indicates the presence/weight of an edge from vertex i to vertex j.\n\nGraphs can also be:\n\nWeighted: Edges have weights (e.g., cost, distance).\nUnweighted: All edges are treated equally.\nCyclic: Contain cycles.\nAcyclic: Do not contain cycles.\nConnected: There is a path between every pair of vertices.\nDisconnected: At least one pair of vertices has no path connecting them.\n\nAlgorithms\n\nPrims algorithm ( Minimum spanning trees )\nKruskals algorithm ( Minimum spanning trees )\nDjikstras algorithm ( Shortest path non-negative edge weights)\nBellman-Ford algorithm (Shortest path with negative edge weights)\n"},"Greedy-algorithms":{"title":"Greedy algorithms","links":["Divide-and-conquer","Dynamic-programming","Shortest-paths","Djikstras-algorithm","Minimum-spanning-trees","Prims-algorithm","Kruskals-algorithm"],"tags":[],"content":"Greedy algorithms are algorithms that can be broken down to a series of choices(Divide and conquer, Dynamic programming), each choice is the locally optimal decision at that point with the hope that it will lead to a globally optimal solution.\nExamples include:\n\nShortest paths\n\nDjikstras algorithm (Not technically but in nature)\n\n\nMinimum spanning trees\n\nPrims algorithm\nKruskals algorithm\n\n\n"},"Hardening-Debian":{"title":"Hardening Debian","links":["Ufw","Fail2ban","Sudo","SSH-Config(Host)","Shared-Memory","acct","auditd","logwatch"],"tags":[],"content":"from a fresh install:\n\napt update &amp;&amp; apt upgrade -y\ninstall Ufw, Fail2ban, unattended-upgrades, Sudo\nconfigure automatic security updates: sudo dpkg-reconfigure --priority=low unattended-upgrades\nset up Ufw\nchange SSH Config(Host), change default port, disable root login, disable password auth, allowusers only one. and restart systemctl restart [[ssh]]\nsetup Fail2ban\nmayyyybee secure shared memory with tmpfs /run/shm tmpfs defaults,noexec,nosuid 0 0\ninstall acct for process accounting and systemctl start + enable it\ninstall auditd then start + enable\ninstall logwatch\n\n"},"Hardware-Interrupt":{"title":"Hardware Interrupt","links":[],"tags":[],"content":"Occurs when you plug in a peripheral to the pc"},"Haskell":{"title":"Haskell","links":["Data-Structures-and-Algorithms","Projects","Java","Red-Black-Trees","Physics","Lists-(Haskell)","Math","Python"],"tags":[],"content":"Functional, lazy, statically typed programming language.\nTODO:\n\nImplement some or algorithms in haskell and use them in a Project, for example by making a Java library in haskell to use Red Black Trees to store some data.\nFinish book “Learn Physics with functional programming”.\n\nIntroduction\nThis note is following the online book “Learn You a Haskell for Great Good!”, and is structured mostly like it (That is, in that order).\nFunctions\nIn Haskell functions play a key role. They work a bit like math functions, a function can only take 1 argument at a time but you can make it seem like it takes more by currying, that is function composition. For example:\nmysin x y = sin x + y\nIs a function  that takes a number x and returns a function that takes a number  y and adds it to \\sin{x}. So really there is no need to think of it like math functions but it is sometimes helpful.\nInfix, prefix and postfix functions.\nFunctions can also be infix, prefix and postfix. Usually functions are prefix like in example above, but * is a function (specifically a function that multiplies two numbers), and it is infix. You can turn a prefix function into an infix function by surrounding it with backticks, a good example is the div function which does integer division (div 92 10 → 9) but there may be some confusion as to which number is being devided so for clarity you may write:\nx = 92 `div` 10\nWhich will evaluate to 9.\nConditionals\nIn haskell conditions have to be functions, additionally the else part is necessary:\nsoftmaxpartial x = if x &lt; 0 \n            then 0\n            else x\nVariables\nVariables are functions that don’t have input arguments, just return a value. Therefore all haskell variables are constant.\nmyvar = 10 + 83\nmyvar&#039; = &quot;myvar&quot;\nLists\nLists are homogenous (store values of the same type, e.g. “thisstring” is a list of characters)\nDetails\nList comprehensions are like Mathemathical set comprehensions (also similiar to Python. e.g. for a set of first 10 even natural numbers:\nMath: S = \\{2 \\times x | x \\in N, x &lt;= 10\\}\nHaskell: S = [2 * x | x &lt;- [1 .. 10]] Haskell with additional predicate: S’ = [2 * x | x ← [1 .. 10], x * 2 &gt; 12]\nTypes"},"Java":{"title":"Java","links":["JVM","Types-(Java)","Maven","Gradle"],"tags":[],"content":"\nJDK for dev\nJRE for running\nJDK includes JRE\nGets compiled into bytecode which is then run by JVM.\nGarbage Colleced\n\nObjects are created on the heap. Java’s heap is garbage collectible so JVM automatically allocates memory and frees that memory when it sees that an object can no longer be used.\nAfter creating an object if you set the only referance to that object to null the object is then eligible for garbage collection since it no longer can be accessed\n\n\nMain method is the entry to the app, an app must have a psvm method.\nCompile a .java file to .class with %javac and run it with %java, you need to have JDK to compile\nMore about Types in Java\n2 options of a build system: Maven and Gradle\n"},"Kruskals-algorithm":{"title":"Kruskals algorithm","links":["Minimum-spanning-trees","Prims-algorithm","Min-Heap"],"tags":[],"content":"Kruskals algo is an algo for finding the Minimum spanning trees of a graph. It is similiar to Prims algorithm.\nSteps.\n\nChoose a lowest cost edge.\nChoose another lowest cost edge, but only if adding it to your list of already selected edges doesn’t form a cycle. (MST’s have to be trees and therefore not cyclical.\nkeep going until all edges are connected.\nThis way the time complexity will be: O(|V| \\times |E|)\nThis however can be improved when using Min Heap to store the edges, then it will take  O(n\\times \\log n)\n"},"Lambda-Expressions":{"title":"Lambda Expressions","links":[],"tags":[],"content":"syntax:\nauto x = [variables from the scope you want to bring in] (parameters) -&gt; return type {\n    function body;\n};\nreturn x(3);"},"Launch":{"title":"Launch","links":["Data-Structures-and-Algorithms","CompProg","Cryptohack","Machine-Learning","Math","Physics","Haskell","Nushell","Rust","Nix","Competitions","Cloud","System-Admin","Projects"],"tags":[],"content":"\nData Structures and Algorithms\nCompProg\nCryptohack\nMachine Learning\nMath\nPhysics\nHaskell\nNushell\nRust\nNix\nCompetitions\nCloud\nSystem Admin\nProjects\n"},"Linear-regression":{"title":"Linear regression","links":[],"tags":[],"content":"\nAssumes that the relationship between data and expected output is linear ( can be expressed as f(x) = ax + b, no \\cos, \\sin, x^n ).\nMore commonly, can be expresed as a function that takes n number of arguments (vector / matrix) and returns the product of that times some weights:\nPython example:\n    def get_model_prediction(self, X: NDArray[np.float64], weights: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n        return np.round(np.matmul(X, weights), 5)\n        # X is an Nx3 NumPy array\n        # weights is a 3x1 NumPy array"},"Linux":{"title":"Linux","links":[],"tags":[],"content":"Linux\ntype: folder_brief_live"},"Lists-(Haskell)":{"title":"Lists (Haskell)","links":[],"tags":[],"content":" \n[1, 2, 3] ++ [4, 5, 6]\n1:[2, 3, 4]\n1:2:3:[]\nWhen using the ++ opearator haskell has to step through all entries in the left list to append to the end. But using the cons (:)  on a single element is instantaneus.\nComparing strings looks at the first one and if they are equal, the next one and so on.\nOperations\n[1, 2, 3] !! 0 :[2, 3] \n[1,2,3]\n\n[3, 2, 1] &gt; [2, 1, 0]\nTrue\n\n[3, 0, 0] &gt; [2, 100, 100]\nTrue\n\n[2, 3, 4] &lt; [2, 1, 0]\nFalse\n\nFunctions\nhead [1,2,3]\n1\n\ntail [1,2,3]\n[2,3]\n\nlast [1,2,3]\n3\n\ninit [1,2,3]\n[1,2]\n\nlength [1,2,3,4,5]\n5\n\nnull []\nTrue\n\nnull [1,2,3]\nFalse\n\nreverse [1,2,3]\n[3,2,1]\n\ntake 3 [1,2,3,4,5]\n[1,2,3]\n\ntake 0 [1,2,3]\n[]\n\ntake 10 [1,2]\n[1,2]\n\ndrop 3 [1,2,3,4,5,6]\n[4,5,6]\n\nelem 4 [1,2,3,4]\nTrue\n\nelem 10 [1,2,3,4]\nFalse\n\n\n\n"},"Machine-Learning":{"title":"Machine Learning","links":["Gradient-descent","Linear-regression"],"tags":[],"content":"\nGradient descent\nLinear regression\n\n"},"Market-volatility":{"title":"Market volatility","links":["Standard-deviation","Variance"],"tags":[],"content":"Statistical measure of the dispersion of returns for a given security or market index. Often measured from the Standard deviation or Variance between those returns. The higher the volatility, the higher the risk.\ne.g. If the stock market rises and falls more than 1% over a sustained period of time it is called a volatile market.\nVolatility represents how high/low the price will swing around the mean price.\n\nImplied volatility measures how volatile the market will be\nHistorical volatility measures how price changes over past time periods\n\nhow to measure\n\nFind the mean price over a period of time.\ncalculate the difference between each data value and the mean (deviations)\nsquare the deviations\nadd the squared deviations\nVariance → divide the sum of the squared deviations by the number of values\nStandard deviation → take the square root of the variance\n\n\\beta coefficient\nif a stock has 0.78 beta coefficient it makes it slightly less volatile than some benchmark (usually S&amp;P500)"},"Math":{"title":"Math","links":["Statistics","Category-Theory"],"tags":[],"content":"\nStatistics\nCategory Theory\n"},"Maven":{"title":"Maven","links":[],"tags":[],"content":"Build system like gradle, contains itself in 1 file pom.xml"},"Min-Heap":{"title":"Min Heap","links":["Heap-Sort"],"tags":[],"content":"Like Max Heap used in Heap Sort, but reversed."},"Minimum-spanning-trees":{"title":"Minimum spanning trees","links":["Graphs-(DSA)","Graph6.excalidraw","Graph62.excalidraw","Prims-algorithm","Kruskals-algorithm"],"tags":[],"content":"Goals\n\nIt is a subgraph (includes all vertices but not all edges).\nThe goal is to find the lowest amount of edges with the lowest connection weight.\nThe result should be a tree (shouldn’t be cyclical)\n\nSpanning tree with unweighed edges\nTransclude of Graph6.excalidraw\n\\text{V - Graph Vertices, E - Graph Edges}\nV = \\{1, 2, 3, 4, 5, 6\\}\nE =\\{(1,2), (2,3), (3,4), (4,5), (5,6), (6,1)\\}\n\\text{V&#039; = MST Vertices, E&#039; = MST Edges}\nV&#039; = V\nE&#039; = \\{(1,2), (2,3), (3,4), (4,5), (5,6)\\}\n|E&#039;| = |V| - 1\nSame thing different way\nTransclude of Graph62.excalidraw\nAlgorithms:\n\nPrims algorithm\nKruskals algorithm\n"},"Monero":{"title":"Monero","links":[],"tags":[],"content":"\nStandard Monero addresses:\n\nTypically 95 characters long\nBegin with the number 4\nYour Feather wallet and MyMonero wallet addresses are likely standard addresses\n\n\nIntegrated addresses:\n\n106 characters long\nCombine a standard address with a payment ID\n\n\nSubaddresses:\n\nUsually 95 characters long\nBegin with the number 8\n\n\n"},"Multivariate-Gaussian-distribution":{"title":"Multivariate Gaussian distribution","links":["Gaussian-distribution"],"tags":[],"content":"It is a type of Gaussian distribution that takes into account multiple variables.\nexample of a 2d distribution (2 variables)\n\nMultivariate gaussian distribution is defined by a covariance matrix \\Sigma and mean vector \\mu. \\mu is the diagnal of \\Sigma and  represents the variance (\\sigma^2) of the i’th variable.\nThe off diagonal values \\sigma_{ij} represent the correlation between i‘th and j‘th random variables.\n\nPositive - the values grow together\nNegative - the values grow oposite to eachother ( one grows the other goes negative)\nZero - the values have no corelation to eachother.\n"},"NP-completeness":{"title":"NP-completeness","links":["Computational-Complexity-Theory","NP-(computational-complexity)","Reduction-(complexity)","Polynomial-Time","P-vs-NP"],"tags":[],"content":"NP-Completeness is a concept in complexity theory. It deals with how hard it is to solve certain types of problems on a computer.\nIn short, problems in the class NP can be checked quickly if you have a potential solution, but we don’t know how to solve them quickly in the first place. A problem is NP-Complete if:\n\nIt’s in NP (meaning solutions can be verified quickly).\nEvery other NP problem can be transformed into it (called a reduction).\n\nIf a fast algorithm (called P time) is found for one NP-Complete problem, all NP problems would become easy to solve quickly too, but we don’t know if such an algorithm exists. This is related to the big unsolved question: P vs NP problem."},"Networking":{"title":"Networking","links":["Router","switch","Firewall"],"tags":[],"content":"hardware\nRouter:\n\nGL.iNet GL-AR750S-Ext (Slate) - This affordable travel router runs OpenWrt, allowing for advanced security configurations and VPN support.\nUbiquiti EdgeRouter X - A bit more advanced, great for learning enterprise-level security features on a budget.\n\nswitch:\n\nTP-Link TL-SG108E (8-port) or TL-SG105E (5-port) - These smart managed switches allow VLAN configuration and port mirroring, useful for security monitoring.\n\nFirewall/Security Appliance: Instead of a hub, consider a dedicated security appliance:\n\nPC Engines APU2 board - Can be used to build a custom firewall/router running pfSense or OPNsense.\n\nAdditional recommendations:\n\nRaspberry Pi 4 - Can be used as a network monitoring device or for running security tools like Snort or Suricata.\nUsed enterprise equipment - Look for older Cisco ASA firewalls for learning advanced security concepts.\n\nSecurity-focused setup ideas:\n\nSet up VLANs to segregate network traffic.\nImplement strong firewall rules and intrusion detection/prevention systems.\nConfigure a VPN for secure remote access.\nSet up network monitoring and logging for security analysis.\nPractice hardening techniques on all devices.\nExperiment with honeypots to learn about threat detection.\n\nRemember, the goal is to learn, so don’t worry if you can’t implement enterprise-grade security immediately. Start with basic security practices and gradually increase complexity as you learn.\nWould you like more information on any specific security aspects or how to set up a particular feature on these devices?\nbooks\n\n\n“Network+ Guide to Networks” by Jill West, Tamara Dean, and Jean Andrews This book covers networking fundamentals and is great for beginners. It includes hands-on projects and labs.\n\n\n“CompTIA Security+ Study Guide” by Mike Chapple and David Seidl While focused on the Security+ certification, this book covers many aspects of network security that would be useful for your project.\n\n\n“Practical Packet Analysis” by Chris Sanders\nThis book will help you understand network traffic, which is crucial for security.\n\n\n“The Practice of Network Security Monitoring” by Richard Bejtlich Excellent for learning how to monitor your network for security threats.\n\n\n“Networking All-in-One For Dummies” by Doug Lowe Despite the title, this is a comprehensive guide that covers a wide range of networking topics in an accessible way.\n\n\n“CCNA 200-301 Official Cert Guide” by Wendell Odom While aimed at Cisco certification, this book provides a thorough understanding of networking concepts.\n\n\n“pfSense 2.4 Applied” by Drew Pate\nIf you decide to use pfSense on your custom firewall, this book is a great guide.\n\n\nRemember, technology changes rapidly, so try to get the most recent editions of these books. Also, supplement your reading with online resources, as they’re often more up-to-date with the latest developments.\nWould you like recommendations for any online resources or courses to complement these books?"},"Nix-modules":{"title":"Nix modules","links":[],"tags":[],"content":""},"Nix":{"title":"Nix","links":["declarative","NixOS","Nixpkgs","Nixpgs-modules","Nixpkgs-modules"],"tags":[],"content":"Nix is a package manager as well as a functional declarative language for reproducible and declarative environments. It is also the base of NixOS.\nIn the Nix language you use Nixpkgs modules, to orgnize the code into modules.\nThe nix language has a function import which has a special attribute that when it’s called on a directory instead of a file, it executes the default.nix of that directory. Which is similiar to the Nixpkgs modules’ imports parameter."},"NixOS":{"title":"NixOS","links":["Nix","configuration.nix","flake.nix"],"tags":[],"content":"NixOS is a linux distribution built on the Nix  package manager. It is supposed to be an OS as Code. To manage packages and settings on a NixOS system the user uses configuration.nix as well as flake.nix."},"Nixpgs-modules":{"title":"Nixpgs modules","links":["Nix","Nixpkgs"],"tags":[],"content":"Module for organizing code in the Nix language.\nBasic structure:\n{lib, config, options, pkgs, ...}:\n{\n  # Importing other Modules\n  imports = [\n    # ...\n    ./xxx.nix\n  ];\n  foo.bar.enable = true;\n  # Other option declarations\n  # ...\n}\nThis is a Nix function definition. And it takes 4 arguments by default (Automatically generated, automatically injected, declaration free):\n\nlib is a collection of useful functions, included with Nixpkgs.\nconfig is a set of all options’ valus in the current environment\noptions is a set of all options’ in all modules in the environment\npkgs is a collection containing all packages in Nixpkgs + a few utility functions.\nmodulesPath: A parameter available only in NixOS, which is a path pointing to nixpkgs/nixos/modules.\n\nIt is defined in nixpkgs/nixos/lib/eval-config-minimal.nix#L43.\nIt is typically used to import additional NixOS modules and can be found in most NixOS auto-generated hardware-configuration.nix files.\n\nThe Nixpkgs module system provides two ways to pass non-default parameters:\n\n\nThe specialArgs parameter of the nixpkgs.lib.nixosSystem function\nUsing the _module.args option in any module to pass parameters\n"},"Nixpkgs-modules":{"title":"Nixpkgs modules","links":["Nixpkgs"],"tags":[],"content":"Simplified Nixpkgs module:\n{lib, config, options, pkgs, ...}:\n{\n  # Importing other Modules\n  imports = [\n    # ...\n    ./xxx.nix\n  ];\n  for.bar.enable = true;\n  # Other option declarations\n  # ...\n}\nInputs\n\nlib: std library\nconfig set of all options’ values in the current environment\noptions all options of all modules in the current environment\npkgs collection of all nixpkgs packages.\n\nIf you need to pass non-default arguments use specialArgs:\n{\n  inputs = {\n    nixpkgs.url = &quot;github:NixOS/nixpkgs/nixos-24.11&quot;;\n    another-input.url = &quot;github:username/repo-name/branch-name&quot;;\n  };\n \n  outputs = inputs@{ self, nixpkgs, another-input, ... }: {\n    nixosConfigurations.my-nixos = nixpkgs.lib.nixosSystem {\n      system = &quot;x86_64-linux&quot;;\n \n      # Set all inputs parameters as special arguments for all submodules,\n      # so you can directly use all dependencies in inputs in submodules\n      specialArgs = { inherit inputs; };\n      modules = [\n        ./configuration.nix\n      ];\n    };\n  };\n}\nor the same way with _module.args\nand then receive those values in the module:\n# Nix will match by name and automatically inject the inputs\n# from specialArgs/_module.args into the third parameter of this function\n{ config, pkgs, inputs, ... }:\n{\n  # ...\n}"},"Nixpkgs":{"title":"Nixpkgs","links":["Nix","NixOS"],"tags":[],"content":"Nixpkgs is a repository of packages for Nix and NixOS"},"Nushell":{"title":"Nushell","links":["Powershell"],"tags":[],"content":"Nushell is a data analisys environment with an integrated shell, it works not on text but on objects, kind of like Powershell but doesn’t suck.\ne.g.\n# find all directories\nls | where type == dir\n \n# sort by newest ascending\nls | sort-by modified | reverse\n \n# show all files ending with .json in all subdirectories which don&#039;t have node_modules in their name\nls **/*.json where name !~ node_modules\n \n# show file as structured data\nopen Cargo.toml\n\nBy default output will be in format table -e which means everything expanded but you can see just the top layer by piping it to table.\nQuerying sqlite databases with open data.db | query db &quot;select * from table&quot;, or inspect the schema with open data.db | schema | table\nTranspose with transpose.\nInteract with the data explore\nhttp requests http get example.com/ | table\nparse data open somefile | get propertyName | parse &quot;{day}/{month}/{year}&quot; for dates for example.\nquery web, when used on a http get request can return only the files with some css properties e.g. http get &quot;example.com/&quot; | query web -q &quot;h2&quot; get all h2 headers from this url\nget all distinct authors of commits of a git repo git log | jc --git-log | from json | select author | uniq\n"},"O-notation":{"title":"O notation","links":[],"tags":[],"content":""},"Opcodes":{"title":"Opcodes","links":["Asm"],"tags":[],"content":"also knows as bytecode and machine code.\nCPU has a mapping of machine code (binary or hex)  to actions and registers.\nFor example a series of 0xf 0x02 0x83 could map to Asm instructions add ebx, 0x83.\nBut the same instruction (e.g. add) does not always have to be represented by the same hex value"},"Option":{"title":"Option","links":["Result"],"tags":[],"content":"Represents an optional value.\nEither\n\nSome (contains value)\nNone (does not)\nyou can pattern match it like:\n\nlet someval: Option&lt;T&gt; = whatever.method();\nmatch someval{\n    Some(x) =&gt; println!(&quot;{x}&quot;);\n    None =&gt; println!(&quot;Nothing&quot;);\n}\n.expect() also works here the same as in Result\nlet someval: T  = whatever.method().expect(&quot;Return value or panic&quot;);"},"Ownership-system-(Rust)":{"title":"Ownership system (Rust)","links":[],"tags":[],"content":"Rust’s ownership has 3 main properties\n\nEvery value has an owner\nThere can only be 1 owner at a time.\nWhen value’s owner goes out of scope the object gets deleted.\n"},"Physics":{"title":"Physics","links":["Classical-physics"],"tags":[],"content":"Learning books:\n\nLean physics with functional programming\nTheoretical minimum - Leaonard Susskind\n\nClassical physics"},"Pip":{"title":"Pip","links":["Venv","/"],"tags":[],"content":"\nTo install a python program package globally - pipx\nUsually you want to make a Venv\nAlternatively some people like to use Conda and it’s many distributions (miniconda, anaconda)\n"},"Powershell":{"title":"Powershell","links":[],"tags":[],"content":"Reference of commands:\n# Move all .zip files to desktop\nGet-ChildItem &quot;*.zip&quot; | Move-Item -Path &quot;C:\\Users\\lain\\Desktop&quot;\n \n# check PATH \n$env:PATH -split &#039;;&#039;\n \n# check aliases\nGet-Alias aliasname\n \n# PWD\nGet-Location"},"Prims-algorithm":{"title":"Prims algorithm","links":["Minimum-spanning-trees"],"tags":[],"content":"Prim’s algorithm is an algorithm for finding the Minimum spanning trees of a graph. It is super simple.\nSteps\n\nChoose a vertice\nChoose a lowest cost edge connected to one of your already connected vertices.\nAdd the vertice that edge connects to to your list of connected vertices.\nSo in plain english just grow your tree from a single point always choosing the lowest cost edge and adding it to the tree.\n"},"Program-Execution":{"title":"Program Execution","links":["Opcodes","Asm"],"tags":[],"content":"Program executes by loading itself into memory and then instruction by instruction the cpu fetches the machine code of the program from RAM ==(fetch-execute cycle).\nInstruction pointer (ip)== points to the place in memory where the next instruction is waiting for the cpu to fetch it.\nExample of program execution on linux:\n\n./app calls execve(&quot;Path to file&quot;) syscall which takes us to the kernel space which loads it and does some setup for it as well as trying to identify the binaries format. If it succeeds it goes to the next step\nStarts a new process\n"},"Projects":{"title":"Projects","links":["System-Admin"],"tags":[],"content":"\nJava Spring boot review classifier\n\nwebsite classifying reviews\nfeedback receiver\nadmin dashboard\nrecomendation system\nnatural language searching\n\n\nNixOS home lab\nCar Marketplace\nDecentralized discord with blockchain-esque architecture.\nModel a game mathematically\n"},"Python":{"title":"Python","links":[],"tags":[],"content":"It does not need an introduction."},"RDS":{"title":"RDS","links":["Security-Group","CloudWatch"],"tags":[],"content":"Managed Relational Database Service\n\nMake sure to check Security Group settings. Other than that it’s really simple.\nYou can choose to export logs to CloudWatch\nTo configure the database’s config file (e.g. postgresql.conf) go to Parameter groups.\n"},"Red-Black-Trees":{"title":"Red Black Trees","links":["Self-Balancing-BST"],"tags":[],"content":"Belong to Self Balancing BST category. Add colors to help balancing.\nRules:\n\nEvery node is either Red or Black.\nThe root is always Black\nRed nodes cannot have any Red children.\nEvery path from a node to it’s decendant NIL nodes must have the same number of black nodes along the way.\nNIL nodes are black\n\nTime complexity\n\nInsertion: O(Log n)\n"},"Result":{"title":"Result","links":["Option"],"tags":[],"content":"Works the same as Option but instead of Some(x) or None it has Ok(x) or Err."},"Rust":{"title":"Rust","links":["Ownership-system-(Rust)","Option","Result","Array","Tuple"],"tags":[],"content":"Memory safety baby, strong types baby. Rust’s main feature is it’s compiler and Ownership system (Rust).\nCreating a project\n\ncargo init creates a project in current directory (can make a git repo with --git)\ncargo new &lt;projectname&gt; creates a new directory with the project inside and by default will init a git repo.\nBoth methods put the source code in src/main.rs and create a cargo.toml with the following info:\n\n[package]\nname = &quot;folder name&quot;\nversion = &quot;0.1.0&quot;\nedition = &quot;2021&quot;\n \n[dependencies]\nRun the code with cargo run\nBasic syntax\n\nlet x = 3; creates a variable x (constant)\nlet mut x = 3 creates a mutable variable x\nprintln!(&quot;Hi&quot;); writes to stdout\nuse std::io; imports a library (io in this case)\nlet mut str = String::new() calls a function new associated with the type String to create a new mutable variable initialized to an empty string.\n\nUser input\n\nio::stdin().read_line(&amp;mut str); calls the function read_line from the return of the function stdin (handle to std input) which is part of package io returns. If we hadn’t imported the io library with use std::io; at the beginning of the program, we could still use the function by writing this function call as std::io::stdin\nread_line returns an instance of Result type, this instance can have a value of Ok or Err. You can call the method .expect(“Shit went south”) which if the value is Err will crash the program and print the value passed as an argument.  Otherwise if the value is Ok it will return that value. In case of read_line number of bytes of user input.\n\nUsing packages\n\nadd the package to [dependencies] section of cargo.toml:\n\n[dependencies]\nrand = &quot;0.8.5&quot;\nTypes\n\nOption\nConst has to have explicit type assigned on declaration + can’t use mut\nResult\nArray\nTuple\n"},"S3":{"title":"S3","links":[],"tags":[],"content":""},"SSH-Config(Host)":{"title":"SSH Config(Host)","links":["SSH"],"tags":[],"content":"SSH settings and general config\nPath: /etc/ssh/sshd_config\nimportant settings:\n\nPort (not 22)\nPermitRootLogin no\nPasswordAuthentication no\nAllowUsers username\nAlso LogLevel to VERBOSE, or maybe DEBUG(1-3) but debug only when its just me using the machine since it violates the privacy of users.\n"},"SSH":{"title":"SSH","links":["SSH-Config(Host)","ssh_config"],"tags":[],"content":"\nPublic / private key pair: ssh-keygen to generate. Put private key on client (in ~/.ssh)and public (.pub) on host into ~/.ssh/authorized_keys file.\nHost config\nClient config\n\n"},"Scheduling":{"title":"Scheduling","links":[],"tags":[],"content":"video\nq: how is the process state saved for resuming\n\nLinux uses a scheduling algorith called Completelly Fair Scheduler\nlong time ago kernels used cooperative multitasking but with that badly optimized of poorly designed programs could easily freeze up the whole computer\n"},"Security-Rings":{"title":"Security Rings","links":["x86"],"tags":[],"content":"nowadays the only ones used are ring 0 (kernel) and ring 3 (user mode), seg faults happen because a program tries to read memory not within it’s scope but in kernel mode a program can read everything that’s in memory so in ring 0 seg faults do not exist.\nin intel x86 architecture there is a CPL (current privelage level) which can be read from the lowest 2 bits of the CS (code segment) register (11 or 00, for rings 3 and 0)"},"Self-Balancing-BST":{"title":"Self Balancing BST","links":["AVL-Trees","Red-Black-Trees","B-Trees"],"tags":[],"content":"Category of BST where the goal is to minimize the height of tree to speed up searching.\nExamples:\n\nAVL Trees\nRed Black Trees\nB Trees\n"},"Shared-Memory":{"title":"Shared Memory","links":[],"tags":[],"content":"Shared memory is a portion of memory that can be accessed by multiple programs. It’s often used for inter-process communication and can improve performance in certain scenarios. However, if not properly secured, it can be a security risk.\nWhen we talk about securing shared memory, we’re primarily concerned with preventing two types of attacks:\n\nCode execution attacks: An attacker might try to place malicious code in shared memory and then execute it.\nInformation disclosure: Sensitive data left in shared memory by one process might be read by another unauthorized process.\n\nThe step I mentioned for securing shared memory involves modifying the /etc/fstab file to mount the /run/shm directory (which is used for shared memory) with specific options:\ntmpfs /run/shm tmpfs defaults,noexec,nosuid 0 0\nLet’s break down these options:\n\ntmpfs: This is a temporary filesystem that resides in memory.\ndefaults: This applies the default mount options.\nnoexec: This prevents the execution of any binaries on this mount point.\nnosuid: This prevents the use of setuid/setgid bits, which are special permissions that allow users to run executables with the permissions of the executable’s owner.\n\nBy applying these options, we:\n\nPrevent the execution of any code placed in shared memory (noexec).\nPrevent privilege escalation via setuid/setgid programs in shared memory (nosuid).\n\nThis significantly reduces the risk of an attacker using shared memory as an attack vector, while still allowing legitimate use of shared memory for inter-process communication.\nAfter adding this line to /etc/fstab, you would typically reboot the system or remount the filesystem for the changes to take effect:\nmount -o remount /run/shm"},"Shortest-paths":{"title":"Shortest paths","links":["Graphs-(DSA)","Djikstras-algorithm","Bellman-Ford-algorithm","A*-algorithm"],"tags":[],"content":"Theese algorithms want to find the shortest path from a source node to either another node or all other nodes. They are often represented as Graphs.\nExamples include:\n\nDjikstras algorithm\nBellman-Ford algorithm\nA* algorithm\n"},"Skill-rating-systems":{"title":"Skill rating systems","links":["Elo","Glocko2"],"tags":[],"content":"\nElo\nGlocko2\n\n"},"Software-Interrupt":{"title":"Software Interrupt","links":["Hardware-Interrupt","x86","x64","Asm","Security-Rings"],"tags":[],"content":"Along with Hardware Interrupt are the 2 types interrupts\nAsking the kernel to stop whatever it’s doing and do what i want it to.\nIVT (interrupt vector table) in x86 and IDT (interrupt descriptor table) in x64\n\ne.g. in Asm:\nint 0x2\nwill check the table and switch to kernel mode to jump the IP (instruciton pointer) to the place which stores  Timer 1 block of code and then\niret\nto switch back to user mode and return to the place it was before the interrupt was triggered"},"Standard-deviation":{"title":"Standard deviation","links":["Variance","Market-volatility"],"tags":[],"content":"\\sigma describes how far individual points in a dataset are dispersed from the mean.\nCalculated as square root of Variance. Can help determine consistency of investment returns over time.\nWhen applied to the annual rate of return of an investment it can provide information on that investment’s historical Market volatility."},"State-of-a-system":{"title":"State of a system","links":["System","Set"],"tags":[],"content":"State of a System refers to result of an observation which we can make that will tell us everything we need to know about a system to predict it’s next state.\n\nState-Space: Collection of all states occupied by a system. It is a mathematical Set where elements label all possible states of the system.\n\nSimplest State-Space:\n\nCoin glued to a table heads up: \\{H\\}\nIt will always be heads no matter what.\n\nSecond simplest State-Space:\n\nCoin (not glued) on a table: \\{H, T\\}\nIt can either be Heads or Tails.\n"},"State-variables":{"title":"State variables","links":["Dynamical-system"],"tags":[],"content":"State variables in a Dynamical system describe the current state and help us predict the next one. They are denoted \\sigma, and take values such as \\{1, -1\\}. In the case of a coin on a table example. It could either be heads up or tails up.\nThose variables allow us to describe the system in equations. Since this coin example is discrete for time we will use n instead of t.\nState at the time n is described as \\sigma (n). So for a state that will always be the same (coin glued to the table one side up). We can say \\sigma(n+1) = \\sigma(n).\nOr for a state that will always be the opposite of the last it would be \\sigma(n+1) = - \\sigma(n)."},"Statistics":{"title":"Statistics","links":["Gaussian-processes"],"tags":[],"content":"\nGaussian processes\n"},"Stock-split":{"title":"Stock split","links":[],"tags":[],"content":"Company splitting a single share into multiple to lower it’s price. e.g. nvidia costs 1,200 does a 10:1 stock split. Now everyone with 1 nvidia share have 10 of them and each share costs 120.\n\nStock splits often result in short-term abnormal returns. avg 2% to 4% increase in value around the split announcement. so after announcement stock tends to be overpriced relative to its fundamental value. ~Announcement premium\nThe opposite happens for reverse stock splits (10:1 → 1:10)\n\n\nAnnouncement date - public declaration of intention to split shares, causing an immidiate market reaction\nrecord date - company determines which chareholders are eligible to receive the additional shares from the split; inverstors must own the stock before this date to participate\ndistribution date - new shares are issued\n"},"Sudo":{"title":"Sudo","links":[],"tags":[],"content":"\nsu -\nusermod -aG sudo username\nlogout and login\n"},"Syscalls":{"title":"Syscalls","links":["Software-Interrupt"],"tags":[],"content":"ask the OS kernel to perfrom some action (read from keyboard, write to screen) through a Software Interrupt\nusermode:\nprintf(“Hello, world!”);\nsyscall:\nplease write this string for me\nOn linux, check the Software Interrupt table and prepare registers as needed.\nTo syscall exit:\nmov eax, 0x1    ; exit software interrupt code\nmov ebx, 0x9    ; argument to pass\nint 0x80        ; check the table and do the syscall ??"},"System-Admin":{"title":"System Admin","links":["Nix"],"tags":[],"content":"Reading list:\n\nchar.blog/nixos-homelab Nix\n"},"System":{"title":"System","links":["State-of-a-system","Dynamical-system"],"tags":[],"content":"In classical physics we know everything about a system at a given point in time, and with that knowledge we can know for certain what will happen to the State of the system.\nWe try to think of a system as cointinous and not diescrete but sometimes there is no continous way to get from one state to another (Like in examples in State of a system. Then we have to think of it as discrete.\nSystems can be Dynamical."},"TORvsVPN":{"title":"TORvsVPN","links":[],"tags":[],"content":"\nTOR encrypts and routes traffic through multiple (typically 3) layers of relays (nodes). The goal is for all TOR users to be indistinguishable from one another. Tor nodes are volunteer-operated and decentralized\nVPN is controlled by a company and nodes are centralized.\n“Who controlls the exit node controlls traffic” - The exit node can see unencrypted traffic since it needs to send it between you and the server. HTTPS mitigates this. The exit node can not see the source IP address (you) just the destination and traffic.\n"},"Tailscale":{"title":"Tailscale","links":[],"tags":[],"content":"VPN to securely connect to devices without exposing them to the internet."},"Theta-notation":{"title":"Theta notation","links":[],"tags":[],"content":"For functions that grow at similar pace\nmathemathic definition\n    \\theta (g(n)) = \\{f(n) : \\exists_{c1, c2} \\; \\exists_{n_0 \\in \\mathbb{N}} \\; \\forall_{n &gt; n_0} \\quad 0 \\le c_1 \\times g(n) \\le f(n) \\le c_2 \\times g(n) \\}\nSo we can say that the running time of an algorithm (f(n)) has to be between two functions g(n) multiplied by c_1 and c_2 respectively, but only once n passes a certain threshhold (n_0).\n"},"Tuple":{"title":"Tuple","links":[],"tags":[],"content":"// declare\nlet tup: (i32, f64, u8) = (5012, 0.3, 120);\nlet x = tup.0\nlet y = tup.1\nlet z = tup.2\n// destructure \nlet (x, y, z) = tup;"},"Types-(CPP)":{"title":"Types (CPP)","links":[],"tags":[],"content":"Unsigned types can be prone to bugs best to avoid them, in C++ when comparing a signed integer to unsigned, it gets converted to unsigned which can lead to unexpected behaviour.\nint type can be either 2 or 4 bytes long depending on the machine, to have certainty over the range of the variable you can use cstdint header that includes types which are sure to be of the specified length:\nNameTypeRangeNotesstd::int8_t1 byte signed-128 to 127Treated like a signed char on many systems. See note below.std::uint8_t1 byte unsigned0 to 255Treated like an unsigned char on many systems. See note below.std::int16_t2 byte signed-32,768 to 32,767std::uint16_t2 byte unsigned0 to 65,535std::int32_t4 byte signed-2,147,483,648 to 2,147,483,647std::uint32_t4 byte unsigned0 to 4,294,967,295std::int64_t8 byte signed-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807std::uint64_t8 byte unsigned0 to 18,446,744,073,709,551,615"},"Types-(Java)":{"title":"Types (Java)","links":["tags/java","tags/type","tags/int","tags/long","tags/object","tags/float","tags/double"],"tags":["java","type","int","long","object","float","double"],"content":"java, type, int, long, object, float, double\n\nend assignment with f or L to tell the compiler which you mean\nYou cant assign a int to a byte for example even if the  int variable value is small enough to fit in the byte.\nvariable name must start with a letter, underscore, or a dollar sign $\nthere are no object variables just object references\nyou can only put dogs in an array of type dog but you can put a byte into an int array this is known as IMPLICIT WIDENING\n\nPrimitive table\n\n\nTypesizerange\n\nbooleanJVM Specifictrue or false\nchar16 bit0 - 65536\nbyte8 bit-128 - 127\nshort16 bit-32768 - 32767\nint32 bit-2147483648 - 2147483647\nlong64 bit-huge - huge\nfloat32 bitvaries\ndouble64 bitvaries\n\nDeclaration and initialization\n\nInstance variables get set to zero if not initialized after declaration 0, 0.0, false, null\nLocal variables have to be initialized before usage or the program won’t compile\n\nComparison\n\nPrimitive types: ==\nObjects, to check if they refer to the same exact instance on the heap use == otherwise to check equality use .equals()\n\n"},"Ufw":{"title":"Ufw","links":["SSH"],"tags":[],"content":"firewall program,\n\nto change defaults: ufw default [allow|deny|reject] [incoming|outgoing|routed]\nallow SSH: ufw allow [[ssh]]\nstart ufw: ufw enable\n\ndefault server setup:\n\nallow default outgoing\ndeny default incoming\nallow SSH\n"},"Unity":{"title":"Unity","links":[],"tags":[],"content":"Unity can be exported to 1 of 2 runtimes:\n\nmono (starts a VM and runs with a JIT compiler) (small to medium games)\nil2cpp (translates to cpp and compiles a native binary) (little harder to hack)\n\nhacking\n\n\nmono\n\n\nopen dnSpyEx and patch (don’t use 64bit for 32 bit games) can also use melonloader to make mods, use UnityExplorer plugin to check out the values.\n\n\nil2cpp\n\n\nuse melon loader"},"Variance":{"title":"Variance","links":["Market-volatility","Standard-deviation"],"tags":[],"content":"\\sigma^2 Describes the spread between numbers in a dataset.\nMeasures how far each number in the set is from the mean and thus from every other number in the set. Used by market analysts and traders to determine Market volatility.\n\\sigma^2=\\frac{\\sum_{i=1}^{n}(x_i-\\overline{x})^2}{n-1}\nexample\nif returns for stock in Company ABC are 10% in Year 1, 20% in Year 2, and -15% in Year3, the average of these three returns is:\n\\frac{10\\% + 20\\% + (-15\\%)}{3} = 5\\%\n\ndifferences:\n10\\% - 5\\% = 5\\%\n20\\% - 5\\% = 15\\%\n-15\\% - 5\\% = -20\\%\nsquaring:\n0.25\\%\n2.25\\%\n4.00\\%\nfinal:\nVariance = 0.25\\% + 2.25\\% + 4.00\\% = 6.5\\%\ndivide by N - 1\n\\frac{6.5\\%}{3 - 1} = 3.25\\% = 0.0324\n\nto take the Standard deviation just take the square root of the variance."},"Venv":{"title":"Venv","links":[],"tags":[],"content":"When a virtual environment has been activated, the VIRTUAL_ENV environment variable is set to the path of the environment.\n\ncreate a venv % python3 -m venv ./venv\nactivate a venv % source ./venv/bin/activate\ndeactivate a venv  % deactivate\n"},"Windows":{"title":"Windows","links":[],"tags":[],"content":"This is just here so i have somewhere to link you know what windows is lmao."},"declarative":{"title":"declarative","links":[],"tags":[],"content":""},"djikstragraph.excalidraw":{"title":"djikstragraph.excalidraw","links":[],"tags":["excalidraw"],"content":"⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠ You can decompress Drawing data with the command palette: ‘Decompress current Excalidraw file’. For more info check in plugin settings under ‘Saving’\nExcalidraw Data\nText Elements"},"flake.nix":{"title":"flake.nix","links":["Nix","configuration.nix","NixOS","Nixpkgs-modules","Nix-modules"],"tags":[],"content":"Flakes are Nix’s version of package.json, they generate flake.lock similiar to package-lock.json which locks package versions, Helping produce reproducible environments. To enable flakes put\nnix.settings.experimental-features = [&quot;nix-command&quot; &quot;flakes&quot;]\ninto your configuration.nix.  After enabling this, the go-to configuration file changes from /etc/nixos/configuration.nix to /etc/nixos/flake.nix, and nix will only look at the former when it can’t find the flake.\nTo create a flake from a template, check out the available templates with nix flake show templates.  And create one with nix flake init -t templates#full.\nExample of a simple configuration flake.nix extending configuration.nix file\n{\n  description = &quot;plan9better but nixos is fine&quot;;\n \n  inputs = {\n    # NixOS official package source, using the nixos-24.11 branch here\n    nixpkgs.url = &quot;github:NixOS/nixpkgs/nixos-24.11&quot;;\n  };\n \n  outputs = { self, nixpkgs, ... }@inputs: {\n    nixosConfigurations.bebop = nixpkgs.lib.nixosSystem {\n      system = &quot;x86_64-linux&quot;;\n      modules = [\n        ./configuration.nix\n      ];\n    };\n  };\n}\nIn this example the configuration’s name is bebop, NixOS by default will look for an attribute in the return value of the outputs function named the same as the system hostname (by default “nixos”). So change the hostName in configuration.nix and for the first time run sudo nixos-rebuild switch --flake /etc/nixos#bebop. With bebop substituted for yout configs name. If you changed the hostname in configuration.nix then after reboot hostname will change and the part after “switch” is not necessary anymore. (You can also directly reference a github repo as flake source instead of a file path sudo nixos-rebuild switch --flake github:plan9better/nixos#bebop)\nFlake structure\nflakes adhere to Nixpkgs modules structure.\n\nInputs Specifies dependencies of the flake. This attribute set will be passed to the outputs function after they are fetched. Those dependencies can be:\n\nGit repository (as in example)\nLocal path\nAnother flake\nHere we only define a dependency named nixpkgs, which is the most common way to reference in a flake, i.e., github:owner/name/reference. The reference here can be a branch name, commit-id, or tag. After declaring this attribute we can use it as an argument passed into the outputs function which is exactly what out example does.\n\n\nOutputs is a function that takes an attribute set from inputs and returns an attribute set which represents the build results of the flake.\n\nThe self parameter of the outputs function, refers to this functions output / return value as well as the source tree of the flake.\n\n\nBy default flakes search for a flake.nix file in the root directory of each of it’s dependencies (i.e each item in inputs) and lazily evaluates their outputs function, and then passes that functions return value to it’s own otputs function. You can look at a flake (e.g. the nixos-24.11 flake) to see what you can expect its output function to return. In the flake mentioned before you see that it has a lib attribute, which in turn has a nixosSystem attribute, so we can use them in out flake.\n\nsystem: This is straightforward, it’s the system architecture parameter.\nmodules: This is a list of modules, where the actual NixOS system configuration is defined. The /etc/nixos/configuration.nix configuration file itself is a Nixpkgs Module, so it can be directly added to the modules list for use.\n\n\n\n\n"},"std-unordered_set":{"title":"std unordered_set","links":["std-set","iterator"],"tags":[],"content":"std::unordered_set. Set which is not sorted compared to a regular std::set.\nstd::unordered_set&lt;int&gt; numbers\nMethods:\n\ninsert(T) ::  insert an item\nbegin() :: ret iterator to the begining\nend() :: ret iterator to the end\nfind(T) :: When not found returns iterator to the end, like end() otherwise\ncount(T) :: Int` number of occurences of an element.\n"},"x64":{"title":"x64","links":["x86"],"tags":[],"content":"intels 64bit superset of x86"},"x86":{"title":"x86","links":["x64"],"tags":[],"content":"Intel x86 32 bit format used before x64 which is it’s superset."}}